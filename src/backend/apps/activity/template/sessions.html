{% extends '_partials/_base.html' %}
{% load static %}


{% block pagetitle %}Sesiones{% endblock %}

<!-- {% block breadcumbs %}

<li class="breadcrumb-item text-muted">
    <a href="" class="text-muted">Camino</a>
</li>
<li class="breadcrumb-item text-muted">
    <a href="" class="text-muted">a</a>
</li>
<li class="breadcrumb-item text-muted">
    <a href="" class="text-muted">su pagina</a>
</li>

{% endblock %} -->

{% block content %}

<div class="col-12">
    <div style="margin-left: auto; margin-right: auto;" class="card p-5 card-custom gutter-b example example-compact">

        <h1>Sesiones</h1>

        <select id="session-date-select" style="width: 200px" class="form-control ml-auto my-3">
            <option value="today">Hoy</option>
            <option value="week">Esta Semana</option>
            <option value="month">Este Mes</option>
        </select>

        <table class="table">
            <thead class="thead-dark">
                <tr>
                    <th scope="col">PC</th>
                    <th scope="col">Encendido</th>
                    <th scope="col">Apagado</th>
                    <th scope="col">Tiempo</th>
                </tr>
            </thead>
            <tbody id="session-tbody">
                {% for s in sessions %}
                <tr>
                    <td>{{ s.pc }}</td>
                    <td>{{ s.start }}</td>
                    <td>{{ s.end }}</td>
                    <td>{{ s.time }}</td>
                </tr>
                {% endfor %}

                <tr>
            </tbody>
        </table>


    </div>

</div>



{% endblock %}

{% block scripts %}
<script type="text/javascript" src="https://cdn.rawgit.com/ricmoo/aes-js/e27b99df/index.js"></script>

<script type="text/javascript">
    // Traer los datos según rango de fecha seleccionado
    document.getElementById("session-date-select").onchange = (e) => {
        const { value } = e.target
        fetch(`{% url "getsessions" %}?option=${value}`)
            .then((response) => response.json())
            .then((data) => {
                document.getElementById("session-tbody").innerHTML = data.reduce((acc, curr) => {
                    return acc +
                        `<tr>
                            <td>${curr.pc}</td>
                            <td>${curr.start}</td>
                            <td>${curr.end}</td>
                            <td>${curr.time}</td>
                        </tr>`
                }, '')
            })
    }


    const webSocketUrl = "ws://127.0.0.1:8000/ws/activity/enc/" +
        encryptAES("iamadmin", "gUkXp2s5v8y/B?E(G+KbPeShVmYq3t6w")

    connectWebSocket(webSocketUrl,
        () => { },
        () => { },
        () => { },
        () => { })

    function connectWebSocket(url, onOpen, onClose, onMessage, onError) {
        const socket = new WebSocket(url)

        // Función que se ejecuta cuando se establece la conexión con éxito
        socket.onopen = (event) => {
            console.log('Conexión WebSocket establecida')
            if (onOpen) {
                onOpen(event)
            }
        }

        // Función que se ejecuta cuando se cierra la conexión
        socket.onclose = (event) => {
            console.log('Conexión WebSocket cerrada')
            if (onClose) {
                onClose(event)
            }
        }

        // Función que se ejecuta cuando se recibe un mensaje del servidor
        socket.onmessage = (event) => {
            console.log('Mensaje recibido:', event.data)
            if (onMessage) {
                onMessage(event)
            }
        }

        // Función que se ejecuta cuando se produce un error en la conexión
        socket.onerror = (event) => {
            console.error('Error de WebSocket:', event)
            if (onError) {
                onError(event)
            }
        }

        function chat_message() {
            print("chat-msg")
        }

        return socket
    }

    function encryptAES(plaintext, key) {
        // Agregar padding al texto para que calce con los 16 bits que pide CBC
        const paddingLength = 16 - (plaintext.length % 16) // Longitud del padding
        const padding = String.fromCharCode(paddingLength).repeat(paddingLength) // Crea el padding con el byte de relleno
        plaintext = plaintext + padding

        // Convertimos la clave y el IV a buffers
        key = new TextEncoder().encode(key)
        iv = new Uint8Array(16)

        // Convertimos el texto plano a un Uint8Array
        plaintext = new TextEncoder().encode(plaintext)

        // Creamos una instancia de AES-256-CBC
        const aesCbc = new aesjs.ModeOfOperation.cbc(key, iv)

        // Encriptamos el texto plano
        const encryptedBytes = aesCbc.encrypt(plaintext)

        // Convertimos el resultado en un string Base64
        const encryptedBase64 = btoa(String.fromCharCode.apply(null, encryptedBytes))

        return encryptedBase64
    }

</script>

{% endblock %}